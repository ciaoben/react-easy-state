{"version":3,"file":"es.es6.js","sources":["../src/view.js","../src/utils.js","../src/store.js"],"sourcesContent":["import { Component, useState, useEffect, useMemo, memo } from \"react\";\nimport { observe, unobserve, raw, isObservable } from \"@nx-js/observer-util\";\n\nexport let isInsideFunctionComponent = false;\nconst COMPONENT = Symbol(\"owner component\");\n\nconst updates = new Map();\n\nexport default function view(Comp) {\n  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n\n  let ReactiveComp;\n\n  if (isStatelessComp) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = memo(props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState();\n\n      // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n      const render = useMemo(\n        () =>\n          observe(Comp, {\n            scheduler: () => setState({}), //The scheduler simply calls setState on relevant observable changes. This delegates the render scheduling to React Fiber\n            lazy: true // A boolean, which controls if the reaction is executed when it is created or not. If it is true, the reaction has to be called once manually to trigger the reactivity process.\n          }),\n        // Adding the original Comp here is necessary to make React Hot Reload work\n        // it does not affect behavior otherwise\n        [Comp]\n      );\n\n      // cleanup the reactive connections after the very last render of the component\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []);\n\n      // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n      isInsideFunctionComponent = true;\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    });\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp;\n    // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n\n        this.state = this.state || {};\n        this.state[COMPONENT] = this;\n\n        // create a reactive render for the component\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}), //The scheduler simply calls setState on relevant observable changes. This delegates the render scheduling to React Fiber\n          lazy: true // A boolean, which controls if the reaction is executed when it is created or not. If it is true, the reaction has to be called once manually to trigger the reactivity process.\n        });\n      }\n\n      render() {\n        return isStatelessComp\n          ? Comp(this.props, this.context)\n          : super.render();\n      }\n\n      // react should trigger updates on prop changes, while easyState handles store changes\n      shouldComponentUpdate(nextProps, nextState) {\n        const { props, state } = this;\n\n        // respect the case when the user defines a shouldComponentUpdate\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        }\n\n        // return true if it is a reactive render or state changes\n        if (state !== nextState) {\n          return true;\n        }\n\n        // the component should update if any of its props shallowly changed value\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return (\n          nextKeys.length !== keys.length ||\n          nextKeys.some(key => props[key] !== nextProps[key])\n        );\n      }\n\n      // add a custom deriveStoresFromProps lifecyle method\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        }\n        // respect user defined getDerivedStateFromProps\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        }\n        // clean up memory used by Easy State\n        unobserve(this.render);\n      }\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name;\n  // static props are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    for (let key of Object.keys(Comp)) {\n      ReactiveComp[key] = Comp[key];\n    }\n  }\n\n  return ReactiveComp;\n}\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component)\n    .map(key => component[key])\n    .filter(isObservable)\n    .map(raw);\n}\n","import { useState } from \"react\";\n\n// try to find the global object\n// it is window in the DOM and global in NodeJS\nconst isDOM = typeof window !== \"undefined\";\nconst isNative = typeof global !== \"undefined\";\nexport const globalObj = isDOM ? window : isNative ? global : undefined;\n\nexport const hasHooks = typeof useState === \"function\";\n","import { useMemo } from 'react'\nimport { observable } from '@nx-js/observer-util'\nimport { isInsideFunctionComponent } from './view'\nimport { hasHooks } from './utils'\n\nexport default function store (obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (hasHooks && isInsideFunctionComponent) {\n    return useMemo(() => observable(obj), [])\n  }\n  return observable(obj)\n}\n"],"names":["isInsideFunctionComponent","COMPONENT","Symbol","view","Comp","isStatelessComp","prototype","isReactComponent","ReactiveComp","memo","props","setState","useState","render","useMemo","observe","scheduler","lazy","useEffect","unobserve","BaseComp","Component","ReactiveClassComp","constructor","context","state","shouldComponentUpdate","nextProps","nextState","keys","Object","nextKeys","length","some","key","getDerivedStateFromProps","deriveStoresFromProps","stores","mapStateToStores","componentWillUnmount","displayName","name","component","map","filter","isObservable","raw","hasHooks","store","obj","observable"],"mappings":"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"}