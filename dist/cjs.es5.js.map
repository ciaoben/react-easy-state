{"version":3,"file":"cjs.es5.js","sources":["../src/view.js","../src/utils.js","../src/store.js"],"sourcesContent":["import { Component, useState, useEffect, useMemo, memo } from \"react\";\nimport { observe, unobserve, raw, isObservable } from \"@nx-js/observer-util\";\n\nexport let isInsideFunctionComponent = false;\nconst COMPONENT = Symbol(\"owner component\");\n\nconst updates = new Map();\n\nexport default function view(Comp) {\n  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n\n  let ReactiveComp;\n\n  if (isStatelessComp) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = memo(props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState();\n\n      // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n      const render = useMemo(\n        () =>\n          observe(Comp, {\n            scheduler: () => setState({}), //The scheduler simply calls setState on relevant observable changes. This delegates the render scheduling to React Fiber\n            lazy: true // A boolean, which controls if the reaction is executed when it is created or not. If it is true, the reaction has to be called once manually to trigger the reactivity process.\n          }),\n        // Adding the original Comp here is necessary to make React Hot Reload work\n        // it does not affect behavior otherwise\n        [Comp]\n      );\n\n      // cleanup the reactive connections after the very last render of the component\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []);\n\n      // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n      isInsideFunctionComponent = true;\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    });\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp;\n    // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n\n        this.state = this.state || {};\n        this.state[COMPONENT] = this;\n\n        // create a reactive render for the component\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}), //The scheduler simply calls setState on relevant observable changes. This delegates the render scheduling to React Fiber\n          lazy: true // A boolean, which controls if the reaction is executed when it is created or not. If it is true, the reaction has to be called once manually to trigger the reactivity process.\n        });\n      }\n\n      render() {\n        return isStatelessComp\n          ? Comp(this.props, this.context)\n          : super.render();\n      }\n\n      // react should trigger updates on prop changes, while easyState handles store changes\n      shouldComponentUpdate(nextProps, nextState) {\n        const { props, state } = this;\n\n        // respect the case when the user defines a shouldComponentUpdate\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        }\n\n        // return true if it is a reactive render or state changes\n        if (state !== nextState) {\n          return true;\n        }\n\n        // the component should update if any of its props shallowly changed value\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return (\n          nextKeys.length !== keys.length ||\n          nextKeys.some(key => props[key] !== nextProps[key])\n        );\n      }\n\n      // add a custom deriveStoresFromProps lifecyle method\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        }\n        // respect user defined getDerivedStateFromProps\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        }\n        // clean up memory used by Easy State\n        unobserve(this.render);\n      }\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name;\n  // static props are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    for (let key of Object.keys(Comp)) {\n      ReactiveComp[key] = Comp[key];\n    }\n  }\n\n  return ReactiveComp;\n}\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component)\n    .map(key => component[key])\n    .filter(isObservable)\n    .map(raw);\n}\n","import { useState } from \"react\";\n\n// try to find the global object\n// it is window in the DOM and global in NodeJS\nconst isDOM = typeof window !== \"undefined\";\nconst isNative = typeof global !== \"undefined\";\nexport const globalObj = isDOM ? window : isNative ? global : undefined;\n\nexport const hasHooks = typeof useState === \"function\";\n","import { useMemo } from 'react'\nimport { observable } from '@nx-js/observer-util'\nimport { isInsideFunctionComponent } from './view'\nimport { hasHooks } from './utils'\n\nexport default function store (obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (hasHooks && isInsideFunctionComponent) {\n    return useMemo(() => observable(obj), [])\n  }\n  return observable(obj)\n}\n"],"names":["isInsideFunctionComponent","COMPONENT","Symbol","view","Comp","isStatelessComp","prototype","isReactComponent","ReactiveComp","memo","props","useState","setState","render","useMemo","observe","scheduler","lazy","useEffect","unobserve","BaseComp","Component","ReactiveClassComp","context","state","nextProps","nextState","keys","Object","nextKeys","length","some","key","stores","mapStateToStores","displayName","name","component","map","filter","isObservable","raw","hasHooks","store","obj","observable"],"mappings":"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"}